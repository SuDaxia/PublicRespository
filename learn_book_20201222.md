### 马士兵 哔哩哔哩 周老师 串讲

### mmap（memory mapping）技术，让redis、nginx、kafka类application应用程序【快速写入】的数据，
直接让内核kernel、应用application通过mmap映射到同一块操作的内存，
无需再经过应用调用内核【原始：让内核拷贝应用的数据到内核再内存中开辟的空间（不是内核固定空间，指针指向），然后再从内核指向的内存通过驱动写入到磁盘上】
【内核进化后，新组件()nginx、kafka、redis利用新的内核方法，减少拷贝数据，映射到同一内存空间，直接刷写到磁盘上】

### 零拷贝 技术，让redis、nginx、kafka类application应用程序【快速读取】磁盘数据
【原始：经过内核读取磁盘数据，copy复制到用户应用内存空间，经过加工后，又调用系统内核复制到内核空间，再用内核的socket发数据给客户端client】
【内核进化后，新组件，利用新的内核方法，不必复制到用户内存空间，内核读取数据直接通过socket发给了需要数据的客户端client】


### 秒杀系统中 技术点讲解redis、nginx、kafka
##### 秒杀两个问题：并发量、库存超卖
在客户的角度：用户体验
在系统中其它关联系统角度：友好、隔离

用户体验：
(资源)动静分离预热，（有前面更多的页面，例如优惠券、抢购申请资格等等页面，可以埋点，然后统计有多少关注度、收藏夹、定时提醒、历史数据等加算法等预估想抢购的人数，再结合各种预算成本合理安排库存）

仅留核心动态请求，但此时又会有程序脚本外挂刷爆接口：
    进入层：借助ngixn+redis进行重复高频的恶意请求过滤、限流、或隔离
    
redis记录用户的状态：1。新用户、新请求，待付款、确认付款

库存-1操作，多个service是高并发的，到库存操作同步要串行化
redis 内存数据库，KV形式，V有几种类型，并且有本地方法，redis整体是个单线程串行化，redis效率很高，因为底层使用的epoll

当库存到0的时候，为了让无效请求不再进入系统，直接在前端脚本读到库存为0了，前端就不再发请求，就是本地假的页面告知抢购失败之类（小米的做法）

后面用户确认到自己抢购到了，进入到订单页面，服务后端读取redis读到用户状态后，开始生成订单，然后真正操作db数据库的库存等数据
【此处如果并发太高，同步可能还是压力大，需要将其异步跳转到另外的链路，比如将其发到另外的MQ kafka消息队列】

后面订单产生再拉取收银支付的接口（很有可能是调用第三方的支付接口）【这里也可以走再一个另外的MQ kafka消息队列】
前端真正抢到的用户打开支付的访问就是这里的队列了

但有个问题，就是用户不支付了（逃单），秒杀、交易系统规则：一，真正付款成功之后db库存才真正-1，二，一定时间后订单无效，不再有机会

真正的秒杀(不同于太高价格再打折的假秒杀)活动目标在于：带来用户，少卖没关系，还少亏本，超卖抢购到了后面又没了才伤用户伤商誉

----------引申，如果不是亏本的秒杀活动，就想多卖货，怎么做？？因为前面都是利用技术避免超卖滴血大亏本
所以，现在大数据火热，就是利用各种数据，例如日志、nginx、app来源、链接来源、广告来源，URL、URI、公众号、微博等等，看哪个渠道引流最多，
然后交易数据量，渠道到成交转化率、收益率、获客成本、获客率、订单成本、订单收益率等等等等等等

【成本、流量、客户、收益.....】




### 接着昨天的也就是20201222日

### 数据库的发展,单机文件系统->分布式存储系统和常用数据库 mysql/hbase/hdfs



